import pylab as plt
import numpy as np
import itertools
# This module implements the tricubic interpolation on a regular grid
# described in
# http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.89.7835
# Tricubic interpolation in three dimensions F. Lekien and J. Marsden
# 2005
# the link mentioned in the paper is dead, however the files are found at
# https://github.com/nbigaouette/libtricubic
Binv = np.matrix(((1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),(-3,3,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-2,-1,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0),(2,-2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),(-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-3,3,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-2,-1,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0),(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,-2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0),(-3,-0,3,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-2,-0,-1,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0),(-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-3,-0,3,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-2,-0,-1,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0),(9,-9,-9,9,0,0,0,0,0,0,0,0,0,0,0,0,6,-6,3,-3,0,0,0,0,6,3,-6,-3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,2,2,1,0,0,0,0,0,0,0,0,0,0,0,0),(-6,6,6,-6,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-4,4,-2,2,-0,-0,-0,-0,-3,-3,3,3,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-2,-2,-1,-1,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0),(2,0,-2,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,-2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0),(-6,6,6,-6,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-3,3,-3,3,-0,-0,-0,-0,-4,-2,4,2,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-2,-1,-2,-1,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0),(4,-4,-4,4,0,0,0,0,0,0,0,0,0,0,0,0,2,-2,2,-2,0,0,0,0,2,2,-2,-2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0),(0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),(-0,-0,-0,-0,-0,-0,-0,-0,-3,3,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-2,-1,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0),(0,0,0,0,0,0,0,0,2,-2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0),(-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-3,3,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-2,-1,-0,-0,-0,-0,-0,-0),(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,-2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0),(0,0,0,0,0,0,0,0,-3,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-2,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-3,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,-2,0,-1,0,0,0,0,0),(0,0,0,0,0,0,0,0,9,-9,-9,9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,-6,3,-3,0,0,0,0,6,3,-6,-3,0,0,0,0,0,0,0,0,0,0,0,0,4,2,2,1,0,0,0,0),(-0,-0,-0,-0,-0,-0,-0,-0,-6,6,6,-6,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-4,4,-2,2,-0,-0,-0,-0,-3,-3,3,3,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-2,-2,-1,-1,-0,-0,-0,-0),(0,0,0,0,0,0,0,0,2,0,-2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,-2,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0),(0,0,0,0,0,0,0,0,-6,6,6,-6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-3,3,-3,3,0,0,0,0,-4,-2,4,2,0,0,0,0,0,0,0,0,0,0,0,0,-2,-1,-2,-1,0,0,0,0),(-0,-0,-0,-0,-0,-0,-0,-0,4,-4,-4,4,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,2,-2,2,-2,-0,-0,-0,-0,2,2,-2,-2,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,1,1,1,1,-0,-0,-0,-0),(-3,0,0,0,3,0,0,0,-2,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),(-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-3,-0,-0,-0,3,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-2,-0,-0,-0,-1,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0),(9,-9,0,0,-9,9,0,0,6,-6,0,0,3,-3,0,0,0,0,0,0,0,0,0,0,6,3,0,0,-6,-3,0,0,0,0,0,0,0,0,0,0,4,2,0,0,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),(-6,6,-0,-0,6,-6,-0,-0,-4,4,-0,-0,-2,2,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-3,-3,-0,-0,3,3,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-2,-2,-0,-0,-1,-1,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0),(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-3,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,-2,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-3,0,0,0,3,0,0,0,-2,0,0,0,-1,0,0,0),(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,9,-9,0,0,-9,9,0,0,0,0,0,0,0,0,0,0,6,-6,0,0,3,-3,0,0,0,0,0,0,0,0,0,0,6,3,0,0,-6,-3,0,0,4,2,0,0,2,1,0,0),(-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-6,6,-0,-0,6,-6,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-4,4,-0,-0,-2,2,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-3,-3,-0,-0,3,3,-0,-0,-2,-2,-0,-0,-1,-1,-0,-0),(9,-0,-9,-0,-9,-0,9,-0,6,-0,-6,-0,3,-0,-3,-0,6,-0,3,-0,-6,-0,-3,-0,-0,-0,-0,-0,-0,-0,-0,-0,4,-0,2,-0,2,-0,1,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0),(-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,9,-0,-9,-0,-9,-0,9,-0,-0,-0,-0,-0,-0,-0,-0,-0,6,-0,-6,-0,3,-0,-3,-0,6,-0,3,-0,-6,-0,-3,-0,4,-0,2,-0,2,-0,1,-0),(-27,27,27,-27,27,-27,-27,27,-18,18,18,-18,-9,9,9,-9,-18,18,-9,9,18,-18,9,-9,-18,-9,18,9,18,9,-18,-9,-12,12,-6,6,-6,6,-3,3,-12,-6,12,6,-6,-3,6,3,-12,-6,-6,-3,12,6,6,3,-8,-4,-4,-2,-4,-2,-2,-1),(18,-18,-18,18,-18,18,18,-18,12,-12,-12,12,6,-6,-6,6,12,-12,6,-6,-12,12,-6,6,9,9,-9,-9,-9,-9,9,9,8,-8,4,-4,4,-4,2,-2,6,6,-6,-6,3,3,-3,-3,6,6,3,3,-6,-6,-3,-3,4,4,2,2,2,2,1,1),(-6,0,6,0,6,0,-6,0,-4,0,4,0,-2,0,2,0,-3,0,-3,0,3,0,3,0,0,0,0,0,0,0,0,0,-2,0,-2,0,-1,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),(-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-6,-0,6,-0,6,-0,-6,-0,-0,-0,-0,-0,-0,-0,-0,-0,-4,-0,4,-0,-2,-0,2,-0,-3,-0,-3,-0,3,-0,3,-0,-2,-0,-2,-0,-1,-0,-1,-0),(18,-18,-18,18,-18,18,18,-18,12,-12,-12,12,6,-6,-6,6,9,-9,9,-9,-9,9,-9,9,12,6,-12,-6,-12,-6,12,6,6,-6,6,-6,3,-3,3,-3,8,4,-8,-4,4,2,-4,-2,6,3,6,3,-6,-3,-6,-3,4,2,4,2,2,1,2,1),(-12,12,12,-12,12,-12,-12,12,-8,8,8,-8,-4,4,4,-4,-6,6,-6,6,6,-6,6,-6,-6,-6,6,6,6,6,-6,-6,-4,4,-4,4,-2,2,-2,2,-4,-4,4,4,-2,-2,2,2,-3,-3,-3,-3,3,3,3,3,-2,-2,-2,-2,-1,-1,-1,-1),(2,0,0,0,-2,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,-2,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),(-6,6,-0,-0,6,-6,-0,-0,-3,3,-0,-0,-3,3,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-4,-2,-0,-0,4,2,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-2,-1,-0,-0,-2,-1,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0),(4,-4,-0,-0,-4,4,-0,-0,2,-2,-0,-0,2,-2,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,2,2,-0,-0,-2,-2,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,1,1,-0,-0,1,1,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0),(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,-2,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,-2,0,0,0,1,0,0,0,1,0,0,0),(-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-6,6,-0,-0,6,-6,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-3,3,-0,-0,-3,3,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-4,-2,-0,-0,4,2,-0,-0,-2,-1,-0,-0,-2,-1,-0,-0),(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,-4,0,0,-4,4,0,0,0,0,0,0,0,0,0,0,2,-2,0,0,2,-2,0,0,0,0,0,0,0,0,0,0,2,2,0,0,-2,-2,0,0,1,1,0,0,1,1,0,0),(-6,0,6,0,6,0,-6,0,-3,0,3,0,-3,0,3,0,-4,0,-2,0,4,0,2,0,0,0,0,0,0,0,0,0,-2,0,-1,0,-2,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-6,0,6,0,6,0,-6,0,0,0,0,0,0,0,0,0,-3,0,3,0,-3,0,3,0,-4,0,-2,0,4,0,2,0,-2,0,-1,0,-2,0,-1,0),(18,-18,-18,18,-18,18,18,-18,9,-9,-9,9,9,-9,-9,9,12,-12,6,-6,-12,12,-6,6,12,6,-12,-6,-12,-6,12,6,6,-6,3,-3,6,-6,3,-3,6,3,-6,-3,6,3,-6,-3,8,4,4,2,-8,-4,-4,-2,4,2,2,1,4,2,2,1),(-12,12,12,-12,12,-12,-12,12,-6,6,6,-6,-6,6,6,-6,-8,8,-4,4,8,-8,4,-4,-6,-6,6,6,6,6,-6,-6,-4,4,-2,2,-4,4,-2,2,-3,-3,3,3,-3,-3,3,3,-4,-4,-2,-2,4,4,2,2,-2,-2,-1,-1,-2,-2,-1,-1),(4,-0,-4,-0,-4,-0,4,-0,2,-0,-2,-0,2,-0,-2,-0,2,-0,2,-0,-2,-0,-2,-0,-0,-0,-0,-0,-0,-0,-0,-0,1,-0,1,-0,1,-0,1,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0),(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,-4,0,-4,0,4,0,0,0,0,0,0,0,0,0,2,0,-2,0,2,0,-2,0,2,0,2,0,-2,0,-2,0,1,0,1,0,1,0,1,0),(-12,12,12,-12,12,-12,-12,12,-6,6,6,-6,-6,6,6,-6,-6,6,-6,6,6,-6,6,-6,-8,-4,8,4,8,4,-8,-4,-3,3,-3,3,-3,3,-3,3,-4,-2,4,2,-4,-2,4,2,-4,-2,-4,-2,4,2,4,2,-2,-1,-2,-1,-2,-1,-2,-1),(8,-8,-8,8,-8,8,8,-8,4,-4,-4,4,4,-4,-4,4,4,-4,4,-4,-4,4,-4,4,4,4,-4,-4,-4,-4,4,4,2,-2,2,-2,2,-2,2,-2,2,2,-2,-2,2,2,-2,-2,2,2,2,2,-2,-2,-2,-2,1,1,1,1,1,1,1,1)))
def wrap(i,j,k, lx, ly, lz, periodic):
    ix = i
    iy = j
    iz = k
    if periodic[0]:
        assert(-1 <= i <= lx)
        if ix >= lx:
            ix -= lx
        elif ix < 0:
            ix += lx
    if periodic[1]:
        assert(-1 <= j <= ly)
        if iy >= ly:
            iy -= ly
        elif iy < 0:
            iy += ly
    if periodic[2]:
        assert(-1 <= k <= lz)
        if iz >= lz:
            iz -= lz
        elif iz < 0:
            iz += lz
    return ix, iy, iz

def dfdx(phi,i,j,k,periodic):
    f = lambda a,b,c : phi[wrap(i+a,j+b,k+c,phi.shape[0],phi.shape[1],phi.shape[2],periodic)]
    if 1 < i < phi.shape[0]-1 or periodic[0]:     # central difference
        return (f(1,0,0) - f(-1,0,0))/2.0
    if i == 0:                                    # forward difference
        return f(1,0,0) - f(0,0,0)
    else:                                         # backward difference
        return f(0,0,0) - f(-1,0,0)

def dfdy(phi,i,j,k,periodic):
    f = lambda a,b,c : phi[wrap(i+a,j+b,k+c,phi.shape[0],phi.shape[1],phi.shape[2],periodic)]
    if 1 < j < phi.shape[1]-1 or periodic[1]:     # central difference
        return (f(0,1,0) - f(0,-1,0))/2.0
    if j == 0:                                    # forward difference
        return f(0,1,0) - f(0,0,0)
    else:                                         # backward difference
        return f(0,0,0) - f(0,-1,0)

def dfdz(phi,i,j,k,periodic):
    f = lambda a,b,c : phi[wrap(i+a,j+b,k+c,phi.shape[0],phi.shape[1],phi.shape[2],periodic)]
    if 1 < k < phi.shape[2]-1 or periodic[2]:     # central difference
        return (f(0,0,1) - f(0,0,-1))/2.0
    if k == 0:                                    # forward difference
        return f(0,0,1) - f(0,0,0)
    else:                                         # backward difference
        return f(0,0,0) - f(0,0,-1)

def d2fdxdy(phi,i,j,k,periodic):
    f = lambda a,b,c : phi[wrap(i+a,j+b,k+c,phi.shape[0],phi.shape[1],phi.shape[2],periodic)]
    if 1 < i < phi.shape[0]-1 or periodic[0]: xcase = 0
    elif i==0: xcase = 2
    else: xcase = 1
    if 1 < j < phi.shape[1]-1 or periodic[1]: ycase = 0
    elif j==0: ycase = 2
    else: ycase = 1
    case = 3*xcase + ycase
    if case == 0: return 0.25*(f(1,1,0)-f(-1,1,0)-f(1,-1,0)+f(-1,-1,0))
    if case == 1: return 0.5*(f(1,0,0)-f(-1,0,0)-f(1,-1,0)+f(-1,-1,0))
    if case == 2: return 0.5*(f(1,1,0)-f(-1,1,0)-f(1,0,0)+f(-1,0,0))
    if case == 3: return 0.5*(f(0,1,0)-f(-1,1,0)-f(0,-1,0)+f(-1,-1,0))
    if case == 4: return (f(0,0,0)-f(-1,0,0)-f(0,-1,0)+f(-1,-1,0))
    if case == 5: return (f(0,1,0)-f(-1,1,0)-f(0,0,0)+f(-1,0,0))
    if case == 6: return 0.5*(f(1,1,0)-f(0,1,0)-f(1,-1,0)+f(0,-1,0))
    if case == 7: return (f(1,0,0)-f(0,0,0)-f(1,-1,0)+f(0,-1,0))
    if case == 8: return (f(1,1,0)-f(0,1,0)-f(1,0,0)+f(0,0,0))
    assert False, "should not get here"

def d2fdxdz(phi,i,j,k,periodic):
    f = lambda a,b,c : phi[wrap(i+a,j+b,k+c,phi.shape[0],phi.shape[1],phi.shape[2],periodic)]
    if 1 < i < phi.shape[0]-1 or periodic[0]: xcase = 0
    elif i==0: xcase = 2
    else: xcase = 1
    if 1 < k < phi.shape[2]-1 or periodic[2]: zcase = 0
    elif k==0: zcase = 2
    else: zcase = 1
    case = 3*xcase + zcase
    if case == 0: return 0.25*(f(1,0,1)-f(-1,0,1)-f(1,0,-1)+f(-1,0,-1))
    if case == 1: return 0.5*(f(1,0,0)-f(-1,0,0)-f(1,0,-1)+f(-1,0,-1))
    if case == 2: return 0.5*(f(1,0,1)-f(-1,0,1)-f(1,0,0)+f(-1,0,0))
    if case == 3: return 0.5*(f(0,0,1)-f(-1,0,1)-f(0,0,-1)+f(-1,0,-1))
    if case == 4: return (f(0,0,0)-f(-1,0,0)-f(0,0,-1)+f(-1,0,-1))
    if case == 5: return (f(0,0,1)-f(-1,0,1)-f(0,0,0)+f(-1,0,0))
    if case == 6: return 0.5*(f(1,0,1)-f(0,0,1)-f(1,0,-1)+f(0,0,-1))
    if case == 7: return (f(1,0,0)-f(0,0,0)-f(1,0,-1)+f(0,0,-1))
    if case == 8: return (f(1,0,1)-f(0,0,1)-f(1,0,0)+f(0,0,0))
    assert False, "should not get here"

def d2fdydz(phi,i,j,k,periodic):
    f = lambda a,b,c : phi[wrap(i+a,j+b,k+c,phi.shape[0],phi.shape[1],phi.shape[2],periodic)]
    if 1 < j < phi.shape[1]-1 or periodic[1]: ycase = 0
    elif j==0: ycase = 2
    else: ycase = 1
    if 1 < k < phi.shape[2]-1 or periodic[2]: zcase = 0
    elif k==0: zcase = 2
    else: zcase = 1
    case = 3*ycase + zcase
    if case == 0: return 0.25*(f(0,1,1)-f(0,-1,1)-f(0,1,-1)+f(0,-1,-1))
    if case == 1: return 0.5*(f(0,1,0)-f(0,-1,0)-f(0,1,-1)+f(0,-1,-1))
    if case == 2: return 0.5*(f(0,1,1)-f(0,-1,1)-f(0,1,0)+f(0,-1,0))
    if case == 3: return 0.5*(f(0,0,1)-f(0,-1,1)-f(0,0,-1)+f(0,-1,-1))
    if case == 4: return (f(0,0,0)-f(0,-1,0)-f(0,0,-1)+f(0,-1,-1))
    if case == 5: return (f(0,0,1)-f(0,-1,1)-f(0,0,0)+f(0,-1,0))
    if case == 6: return 0.5*(f(0,1,1)-f(0,0,1)-f(0,1,-1)+f(0,0,-1))
    if case == 7: return (f(0,1,0)-f(0,0,0)-f(0,1,-1)+f(0,0,-1))
    if case == 8: return (f(0,1,1)-f(0,0,1)-f(0,1,0)+f(0,0,0))
    assert False, "should not get here"

def d3fdxdydz(phi,i,j,k,periodic):
    f = lambda a,b,c : phi[wrap(i+a,j+b,k+c,phi.shape[0],phi.shape[1],phi.shape[2],periodic)]
    if 1 < i < phi.shape[0]-1 or periodic[0]: xcase = 0
    elif i==0: xcase = 2
    else: xcase = 1
    if 1 < j < phi.shape[1]-1 or periodic[1]: ycase = 0
    elif j==0: ycase = 2
    else: ycase = 1
    if 1 < k < phi.shape[2]-1 or periodic[2]: zcase = 0
    elif k==0: zcase = 2
    else: zcase = 1
    case = 9*xcase + 3*ycase + zcase
    if case == 0: return 0.125*(f(1,1,1)-f(-1,1,1)-f(1,-1,1)+f(-1,-1,1)-f(1,1,-1)+f(-1,1,-1)+f(1,-1,-1)-f(-1,-1,-1))
    if case == 1: return 0.25*(f(1,1,0)-f(-1,1,0)-f(1,-1,0)+f(-1,-1,0)-f(1,1,-1)+f(-1,1,-1)+f(1,-1,-1)-f(-1,-1,-1))
    if case == 2: return 0.25*(f(1,1,1)-f(-1,1,1)-f(1,-1,1)+f(-1,-1,1)-f(1,1,0)+f(-1,1,0)+f(1,-1,0)-f(-1,-1,0))
    if case == 3: return 0.25*(f(1,0,1)-f(-1,0,1)-f(1,-1,1)+f(-1,-1,1)-f(1,0,-1)+f(-1,0,-1)+f(1,-1,-1)-f(-1,-1,-1))
    if case == 4: return 0.5*(f(1,0,0)-f(-1,0,0)-f(1,-1,0)+f(-1,-1,0)-f(1,0,-1)+f(-1,0,-1)+f(1,-1,-1)-f(-1,-1,-1))
    if case == 5: return 0.5*(f(1,0,1)-f(-1,0,1)-f(1,-1,1)+f(-1,-1,1)-f(1,0,0)+f(-1,0,0)+f(1,-1,0)-f(-1,-1,0))
    if case == 6: return 0.25*(f(1,1,1)-f(-1,1,1)-f(1,0,1)+f(-1,0,1)-f(1,1,-1)+f(-1,1,-1)+f(1,0,-1)-f(-1,0,-1))
    if case == 7: return 0.5*(f(1,1,0)-f(-1,1,0)-f(1,0,0)+f(-1,0,0)-f(1,1,-1)+f(-1,1,-1)+f(1,0,-1)-f(-1,0,-1))
    if case == 8: return 0.5*(f(1,1,1)-f(-1,1,1)-f(1,0,1)+f(-1,0,1)-f(1,1,0)+f(-1,1,0)+f(1,0,0)-f(-1,0,0))
    if case == 9: return 0.25*(f(0,1,1)-f(-1,1,1)-f(0,-1,1)+f(-1,-1,1)-f(0,1,-1)+f(-1,1,-1)+f(0,-1,-1)-f(-1,-1,-1))
    if case == 10: return 0.5*(f(0,1,0)-f(-1,1,0)-f(0,-1,0)+f(-1,-1,0)-f(0,1,-1)+f(-1,1,-1)+f(0,-1,-1)-f(-1,-1,-1))
    if case == 11: return 0.5*(f(0,1,1)-f(-1,1,1)-f(0,-1,1)+f(-1,-1,1)-f(0,1,0)+f(-1,1,0)+f(0,-1,0)-f(-1,-1,0))
    if case == 12: return 0.5*(f(0,0,1)-f(-1,0,1)-f(0,-1,1)+f(-1,-1,1)-f(0,0,-1)+f(-1,0,-1)+f(0,-1,-1)-f(-1,-1,-1))
    if case == 13: return (f(0,0,0)-f(-1,0,0)-f(0,-1,0)+f(-1,-1,0)-f(0,0,-1)+f(-1,0,-1)+f(0,-1,-1)-f(-1,-1,-1))
    if case == 14: return (f(0,0,1)-f(-1,0,1)-f(0,-1,1)+f(-1,-1,1)-f(0,0,0)+f(-1,0,0)+f(0,-1,0)-f(-1,-1,0))
    if case == 15: return 0.5*(f(0,1,1)-f(-1,1,1)-f(0,0,1)+f(-1,0,1)-f(0,1,-1)+f(-1,1,-1)+f(0,0,-1)-f(-1,0,-1))
    if case == 16: return (f(0,1,0)-f(-1,1,0)-f(0,0,0)+f(-1,0,0)-f(0,1,-1)+f(-1,1,-1)+f(0,0,-1)-f(-1,0,-1))
    if case == 17: return (f(0,1,1)-f(-1,1,1)-f(0,0,1)+f(-1,0,1)-f(0,1,0)+f(-1,1,0)+f(0,0,0)-f(-1,0,0))
    if case == 18: return 0.25*(f(1,1,1)-f(0,1,1)-f(1,-1,1)+f(0,-1,1)-f(1,1,-1)+f(0,1,-1)+f(1,-1,-1)-f(0,-1,-1))
    if case == 19: return 0.5*(f(1,1,0)-f(0,1,0)-f(1,-1,0)+f(0,-1,0)-f(1,1,-1)+f(0,1,-1)+f(1,-1,-1)-f(0,-1,-1))
    if case == 20: return 0.5*(f(1,1,1)-f(0,1,1)-f(1,-1,1)+f(0,-1,1)-f(1,1,0)+f(0,1,0)+f(1,-1,0)-f(0,-1,0))
    if case == 21: return 0.5*(f(1,0,1)-f(0,0,1)-f(1,-1,1)+f(0,-1,1)-f(1,0,-1)+f(0,0,-1)+f(1,-1,-1)-f(0,-1,-1))
    if case == 22: return (f(1,0,0)-f(0,0,0)-f(1,-1,0)+f(0,-1,0)-f(1,0,-1)+f(0,0,-1)+f(1,-1,-1)-f(0,-1,-1))
    if case == 23: return (f(1,0,1)-f(0,0,1)-f(1,-1,1)+f(0,-1,1)-f(1,0,0)+f(0,0,0)+f(1,-1,0)-f(0,-1,0))
    if case == 24: return 0.5*(f(1,1,1)-f(0,1,1)-f(1,0,1)+f(0,0,1)-f(1,1,-1)+f(0,1,-1)+f(1,0,-1)-f(0,0,-1))
    if case == 25: return (f(1,1,0)-f(0,1,0)-f(1,0,0)+f(0,0,0)-f(1,1,-1)+f(0,1,-1)+f(1,0,-1)-f(0,0,-1))
    if case == 26: return (f(1,1,1)-f(0,1,1)-f(1,0,1)+f(0,0,1)-f(1,1,0)+f(0,1,0)+f(1,0,0)-f(0,0,0))
    assert False, "should not get here"

class TriCubicInterp(object):
    def __init__(self, phi, h=(1,1,1), periodic=(False,False,False)):
        assert phi.ndim == 3, "only three dimensional arrays"
        self.phi = phi
        self.h = h
        self.pdict = {}
        self.cache = {}
        self.periodic = periodic

    def __call__(self, p):
        coeff = self.get_coeff_point(p)

        # evaluate the expression
        d = np.remainder(p,self.h)
#        d /= self.h

        l = 0
        value = 0
        for i in range(4):
            for j in range(4):
                for k in range(4):
                    value += coeff[l] * d[0]**i * d[1]**j * d[2]**k
                    l +=1
        return value

    def get_coeff_point(self,p):
        cell = np.floor_divide(p,self.h)
        ix,iy,iz = map(int, cell)

        phi = self.phi
        (x,y,z) = (phi.shape[0],phi.shape[1],phi.shape[2])

        print(p)
        ix, iy, iz = wrap(ix,iy,iz, x,y,z, self.periodic)

        if ix<0 or ix >= self.phi.shape[0]: assert False
        if iy<0 or iy >= self.phi.shape[1]: assert False
        if iz<0 or iz >= self.phi.shape[2]: assert False

        if (ix,iy,iz) in self.cache:
            return self.cache[(ix,iy,iz)]

        offsets = np.array(((0, 0, 0),
                            (1, 0, 0),
                            (0, 1, 0),
                            (1, 1, 0),
                            (0, 0, 1),
                            (1, 0, 1),
                            (0, 1, 1),
                            (1, 1, 1)))

        # this is the b vector from equation 11 in Lekien and Marsden
        ijk = [tuple(wrap(ix+ii, iy+jj, iz+kk,x,y,z,self.periodic)) for ii,jj,kk in offsets]
        b = tuple(itertools.chain (
            (phi[i,j,k] for i,j,k in ijk),
            (dfdx(phi,i,j,k,self.periodic)/self.h[0] for i,j,k in ijk),
            (dfdy(phi,i,j,k,self.periodic)/self.h[1] for i,j,k in ijk),
            (dfdz(phi,i,j,k,self.periodic)/self.h[2] for i,j,k in ijk),
            (d2fdxdy(phi,i,j,k,self.periodic)/self.h[0]/self.h[1] for i,j,k in ijk),
            (d2fdxdz(phi,i,j,k,self.periodic)/self.h[0]/self.h[2] for i,j,k in ijk),
            (d2fdydz(phi,i,j,k,self.periodic)/self.h[1]/self.h[2] for i,j,k in ijk),
            (d3fdxdydz(phi,i,j,k,self.periodic)/self.h[0]/self.h[1]/self.h[2] for i,j,k in ijk)))

        coeff = np.array((Binv*np.matrix(b).T).T[0])[0]
        assert not (ix,iy,iz) in self.cache
        self.cache[(ix,iy,iz)] = coeff
        return coeff


if __name__ == '__main__':

    X,Y,Z = np.meshgrid(np.linspace(0,5,6),
                        np.linspace(0,5,6),
                        np.linspace(0,5,6))

    def f(x,y,z):
        return 0.5*x**2 + 0.3*y**2 + z**2 - 3**2
    phi = f(X,Y,Z)
    tci = TriCubicInterp(phi)

    # quickly test an interior point
    point = np.array((0.0, 0, 4.2))
    #np.testing.assert_almost_equal(tci(point), f(*point))
    print(tci(point), f(*point))
    #assert (2,2,2) in tci.cache


    nX,nY,nZ = np.meshgrid(np.linspace(0,2,21),
                           np.linspace(0,2,21),
                           np.linspace(0,2,21))

    res = np.zeros_like(nX)
    for i in range(21):
        for j in range(21):
            for k in range(21):
                res[i,j,k] = tci(np.array((nX[i,j,k],nY[i,j,k],nZ[i,j,k])))

    # plt.matshow(res[:,0,:])
    # plt.colorbar()
    # plt.show()
    # plt.matshow(f(nX,nY,nZ)[:,0,:])
    # plt.colorbar()
    # plt.show()

    # plt.matshow(res[:,0,:]-f(nX,nY,nZ)[:,0,:])
    # plt.colorbar()
    # plt.show()

    plt.subplot(211)
    plt.contour(res[0,:,:],range(-8,-3))
    plt.colorbar()
    plt.subplot(212)
    plt.contour(f(nX,nY,nZ)[0,:,:], range(-8,-3))
    plt.colorbar()
    plt.show()




    print
    1/0

    # make sure we can recover the corner points
    for i in range(5):
        for j in range(5):
            for k in range(5):
                np.testing.assert_almost_equal(tci(np.array((i,j,k))),
                                               phi[i,j,k])

    # fuzz test
    for i in range(1000):
        test_point = np.random.rand(3)*5

        print(test_point, tci(test_point), f(*test_point))
        np.testing.assert_almost_equal()
